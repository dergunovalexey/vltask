# Задание 1
# Реализуйте функцию, принимающую в качестве входного параметра имя директории и
# выводящую на экран содержащиеся в ней файлы. Исходная функция должна
# вызываться рекурсивно для вложенных директорий. Не используйте os.walk
# в вашем решении.
import os


def print_file_names(path: str) -> None:
    """
    Printing file names func
    """
    dirs = []
    for name in os.listdir(path):
        new_path = f'{path}/{name}'
        if os.path.isfile(new_path):
            print(f'{path} ===> {name}')
        else:
            dirs.append(new_path)
    for d in dirs:
        print_file_names(d)


# Задание 2
# Каков результат работы данной программы? Поясните ваш ответ.
# Как бы вы изменили функцию extendList для получения
# предполагаемого результата?

# Данная функция реализует добавление елемента в список
def extendList(val, list=[]):
    """
    Необходимо добавить подробный докстринг для остальных разработчиков.

    Лучше переписать название в снек-кейс, поскольку это более питоничнее
    и лучше читается (extend_list).

    Необходимо переписать название функции, поскольку данное название
    предполагает, что мы будем расширять список другим списком. Но мы в теле
    функции производим добавление элемента в список. Данное название вводит в
    заблуждение. Или переписываем название функции на append_elm_to_list, или
    переписываем тело функции на операцию extend и принимаем в качестве 2х
    аргументов списки.

    Здесь требуется назвать переменную list иначе, поскольку в неймспейсе
    мы изменяем ключевое слово инициализации списка (list).

    Необходимо убрать дефолтный список в функции, это вероятнее всего приведет
    к ошибке. Список является изменяемым объектом в python => при инициализации
    данной функции создается объект класса list, который является дефолтным.
    Если мы не будем передавать в явном виде список как параметр, то операция
    добавления в список будет приводить в один инициализированный объект класса
    list. Это противоричит принципу питоничности, явное лучше неявного

    Плохая практика - передавать в функцию как аргументы изменяемые объекты.
    В теле функции мы можем изменить объект и не ожидать того, что этот объект
    будет изменен в других участках кода. Это может приводить к офибкам.

    Было бы здорово указать типизацию параметров функции и типизацию
    возвращаемого результата.

    Ради одной строчки создавать функцию? Это овер кил. Не стоит делать это...
    Лучше явным образом в коде вызывать встроенный метод append у класса list.
    Это будет лучше читаться другими разработчиками.
    """
    list.append(val)
    return list

# Здесь уже прошла инициализация у функции и мы уже имеем дефолтный объект
# класса list

list1 = extendList(10)  # Здесь мы добавили в наш дефолтный объект, число 10
# В переменной list1 находится ссылка на дефолтный список, [10]
list2 = extendList(123,[])  # Здесь мы передали список в явном виде => создали
                            # новый объект и положили в него число 123
# В переменной list2 находится ссылка на список, [123]
list3 = extendList('a')  # Здесь мы добавили в наш дефолтный список строку "а"
# В переменной list3 находится ссылка на дефолтный список, [10, "a"]

# Если мы работаем на python3.6+, то лучше писать f-строки, они быстрее работают
# и являются более удобными.
print("list1 = %s" % list1)  # print(f'list1 = {list1}')
# list1 = [10, 'a']
print("list2 = %s" % list2)  # print(f'list2 = {list2}')
# list2 = [123]
print("list3 = %s" % list3)  # print(f'list3 = {list3}')
# list3 = [10, 'a']


# Задание 3
# Что такое списковое включение (list comprehension)?
# Приведите пример такой операции.

"""
list comprehension - это инлайновый итератор или генератор. Он заменяет цикл 
for и может дополняться различными логическими if else конструкциями. Работает 
он быстрее обычного итератора, но слишком большие и сложные логические 
конструкции делают его совершенно нечитаемым для разработчиков.

Примеры:
[x if x % 2 == 0 else 100 for x in range(50) if x] - итератор
(x if x % 2 == 0 else 100 for x in range(50) if x) - генератор
"""


# Задание 4
# Приведите пример трех разных способов получения каждого
# третьего элемента в списке.

example_list = [x for x in range(10)]

# Самое рациональное для таких операций - slice

# slice
print(example_list[2::3])
# with enumerate
print([elm for i, elm in enumerate(example_list) if i and i % 3 == 2])
# without enumerate
from typing import Iterable

def getting_third_elements(secuence: Iterable) -> list:
    """
    If you want getting every third element from sequence, do this.
    """
    i = 1
    out = []
    for elm in example_list:
        if not i % 3:
            out.append(elm)
        i += 1

    return out

print(getting_third_elements(example_list))


# Задание 5
# В чем разница между списком (list) и кортежем (tuple)?
# Приведите примеры их использования.

"""
Списки - изменяемые объекты. Кортежи - неизменяемые объекты.

В список можно добавлять или убирать элементы, все эти действия можно совершать 
многократно и они будут производиться над одним объектом.

Если же мы хотим добавить элемент в кортеж или убрать, то мы вынуждены создавать 
новый кортеж.

Списки занимают больше места в памяти, нежели кортежы. Это происходит из-за 
того, что список хранит в себе дополнительное значене allocated (некоторое 
выделенное значение). 

Python хранит в себе определенную часть малых кортежей, которые использовались в 
ходе выполнения программы и перестали. Это малая часть оптимизации работы. 
Python не создает постоянно новые кортежи, он переиспользует старые, поэтому 
работа с кортежами быстрее работы со списками.

Списки целесообразно использовать, если у нас неопределенное число элементов. 
Если в ходе выполнения некой функции мы хотим накапливать некую 
последовательность значений, а потом работать с ней.

Если у нас всегда известно значение количества элементов, то целесообразнее 
использовать кортежи.

Если из объекта класса генератора мы хотим получить последовательность, то нужно 
смотреть контекст. Иногда уместно использование кортежей, а иногда списков.
"""
class EmptyQueue(Exception):
    pass


class ExampleQueue:
    def __init__(self):
        self.some_list = []
        self.put_index = 0
        self.get_index = -1
        self.count = 0

    def get_element(self):
        if self.count:
            self.count -= 1
            return self.some_list.pop(self.get_index)
        else:
            raise EmptyQueue

    def put_element(self, elm):
        self.count += 1
        self.some_list.insert(self.put_index, elm)


class ExampleTupleUsege:
    def __init__(self):
        self.sequence = [{'name': f'name {x}', 'number': x} for x in range(10)]

    @property
    def params(self):
        return tuple(map(lambda x: (x['name'], x['number']), self.sequence))


# Задание 6
# Каков результат работы данной программы? Поясните ваш ответ.

class Parent(object):
    """
    Унаследовали класс от класса object и указали атрибут класса x = 1
    """
    x = 1


class Child1(Parent):
    """
    Унаследовали класс от класса Parent => все атрибуты и методы класса Parent
    перенесли нашему классу. Нового в класс ничего не добавили.
    """
    pass


class Child2(Parent):
    """
    Унаследовали класс от класса Parent => все атрибуты и методы класса Parent
    перенесли нашему классу. Нового в класс ничего не добавили.
    """
    pass


print(Parent.x, Child1.x, Child2.x)
# Все логично, все классы имеют одно значение атрибута x
Child1.x = 2  # В классе Child1 изменили значение атрибута х на число 2
print(Parent.x, Child1.x, Child2.x)
# Классы Parant и Child2 имеют значения атрибута х = 1, а Child1 значение 2
Parent.x = 3  # В родительском классе изменили значение атрибута х на число 3
# Все классы, которые унаследованы от данного класса и в которых не было
# переопределения атрибута х, будут иметь значение атрибута равное числу 3
print(Parent.x, Child1.x, Child2.x)
# Классы  Parent и Child2 имеют значения атрибута x равное 3, поскольку
# родительский класс изменил значение данного атрибута и в классе Child2 не
# происходило переопределение значение данного атрибута. А класс Child1 будет
# иметь значение атрибута х равное 2, поскольку внутри класса Child1 было явным
# образом вызвано переопределение атрибута х => изменение значения атрибута х в
# родительском классе не производит изменения на значения атрибута х в данном
# классе.


# Задание 7
# Имеется следующий потомок класса словаря:

class DefaultDict(dict):
    def __missing__(self, key):
        return []

# Будет ли приведенный ниже код работать? Почему?
d = DefaultDict()
d['foobar'] = 127

"""
Магический метод __missing__ позволяет определить возвращаемое дефолтное 
значение, при получении информации по отсутствующему в словаре ключу. В нашем 
словаре при получении значения по несуществующему ключу теперь будет 
возвращаться объект пустого списка.
 
В коде мы создаем экземпляр нашего словаря и записываем пару ключ-значение.
Далее мы не пытаемся получение значение по какому-либо ключу. Если бы пытались
получить значение по ключу 'foobar', то в ответ получили бы 127. А если 
попробовали взять по любому другому хэшируемому ключу, то в ответ получили бы 
пустой список.

=> код будет работать!
"""

# Задание 8
# Каков результат работы данной программы? Поясните ваш ответ.

list = ['a', 'b', 'c', 'd', 'e']  # имеем список из 5 элементов
print(list[10:])
"""
Здесь мы пытаемся взять слайс с элемента под индексом 10 до конца списка с 
шагом 1. Слайс возвращает список. Значений в нашем списке всего 5 => слайс 
вернет пустой список. 

Но если бы мы пытались получить элемент под индексом 10, тогда мы бы получили 
исключение, поскольку данного элемента нет.  
"""
